{
  "language": "Solidity",
  "sources": {
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nerror TokenERC20__NotEnoughTokens();\nerror TokenERC20__NotEnoughAllowance();\nerror TokenERC20__ZeroAddressNotAllowed();\nerror TokenERC20__NotOwner();\n\ncontract TokenERC20 {\n    // public variables will auto-generate getter functions\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    address private _owner;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(uint256 value, address indexed from, address indexed to);\n    event Approval(uint256 value, address indexed from, address indexed to);\n    event Burn(address indexed from, uint256 value);\n    event OwnershipTransferred(address oldOwner, address newOwner);\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) {\n        totalSupply = initialSupply * 10**uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert TokenERC20__NotOwner();\n        _;\n    }\n\n    function _transfer(\n        uint256 _value,\n        address _from,\n        address _to\n    ) internal {\n        if (_to == address(0x0) || _from == address(0x0))\n            revert TokenERC20__ZeroAddressNotAllowed();\n        if (balanceOf[_from] < _value) revert TokenERC20__NotEnoughTokens();\n        balanceOf[_to] += _value;\n        balanceOf[_from] -= _value;\n        emit Transfer(_value, _from, _to);\n    }\n\n    function transfer(uint256 _value, address _to)\n        public\n        returns (bool success)\n    {\n        _transfer(_value, msg.sender, _to);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     */\n    function transferFrom(\n        uint256 _value,\n        address _from,\n        address _to\n    ) public returns (bool success) {\n        if (allowance[_from][msg.sender] < _value)\n            revert TokenERC20__NotEnoughAllowance();\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_value, _from, _to);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     */\n    function approve(uint256 _value, address _spender)\n        public\n        returns (bool success)\n    {\n        if (_spender == address(0x0))\n            revert TokenERC20__ZeroAddressNotAllowed();\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(_value, msg.sender, _spender);\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        if (balanceOf[msg.sender] < _value)\n            revert TokenERC20__NotEnoughTokens();\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value)\n        public\n        returns (bool success)\n    {\n        if (balanceOf[_from] < _value) revert TokenERC20__NotEnoughTokens();\n        if (allowance[_from][msg.sender] < _value)\n            revert TokenERC20__NotEnoughAllowance();\n        balanceOf[_from] -= _value;\n        allowance[_from][msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(_from, _value);\n        return true;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function abandonOwnership() public onlyOwner returns (bool success) {\n        address oldOwner = _owner;\n        _owner = address(0x0);\n        emit OwnershipTransferred(oldOwner, _owner);\n        return true;\n    }\n\n    function changeOwnership(address newOwner)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        if (newOwner == address(0x0))\n            revert TokenERC20__ZeroAddressNotAllowed();\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, _owner);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}